function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import getChildEventSubscriber from './getChildEventSubscriber';
import getChildRouter from './getChildRouter';
import getNavigationActionCreators from './routers/getNavigationActionCreators';
import getChildrenNavigationCache from './getChildrenNavigationCache';

var createParamGetter = route => (paramName, defaultValue) => {
  var params = route.params;

  if (params && paramName in params) {
    return params[paramName];
  }

  return defaultValue;
};

function getChildNavigation(navigation, childKey, getCurrentParentNavigation) {
  var children = getChildrenNavigationCache(navigation);
  var childRoute = navigation.state.routes.find(r => r.key === childKey);

  if (!childRoute) {
    return null;
  }

  if (children[childKey] && children[childKey].state === childRoute) {
    return children[childKey];
  }

  var childRouter = getChildRouter(navigation.router, childRoute.routeName); // If the route has children, we'll use this to pass in to the action creators
  // for the childRouter so that any action that depends on the active route will
  // behave as expected. We don't explicitly require that routers implement routes
  // and index properties, but if we did then we would put an invariant here to
  // ensure that a focusedGrandChildRoute exists if childRouter is defined.

  var focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;

  var actionCreators = _objectSpread({}, navigation.actions, navigation.router.getActionCreators(childRoute, navigation.state.key), childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}, getNavigationActionCreators(childRoute));

  var actionHelpers = {};
  Object.keys(actionCreators).forEach(actionName => {
    actionHelpers[actionName] = (...args) => {
      var actionCreator = actionCreators[actionName];
      var action = actionCreator(...args);
      return navigation.dispatch(action);
    };
  });
  var isFirstRouteInParent = true;
  var parentNavigation = getCurrentParentNavigation();

  if (parentNavigation) {
    isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;
  }

  if (children[childKey] && children[childKey].isFirstRouteInParent() === isFirstRouteInParent) {
    children[childKey] = _objectSpread({}, children[childKey], actionHelpers, {
      state: childRoute,
      router: childRouter,
      actions: actionCreators,
      getParam: createParamGetter(childRoute)
    });
    return children[childKey];
  } else {
    var childSubscriber = getChildEventSubscriber(navigation.addListener, childKey);
    children[childKey] = _objectSpread({}, actionHelpers, {
      state: childRoute,
      router: childRouter,
      actions: actionCreators,
      getParam: createParamGetter(childRoute),
      getChildNavigation: grandChildKey => getChildNavigation(children[childKey], grandChildKey, () => {
        var nav = getCurrentParentNavigation();
        return nav && nav.getChildNavigation(childKey);
      }),
      isFocused: () => {
        var currentNavigation = getCurrentParentNavigation();

        if (!currentNavigation) {
          return false;
        }

        var {
          routes,
          index
        } = currentNavigation.state;

        if (!currentNavigation.isFocused()) {
          return false;
        }

        if (routes[index].key === childKey) {
          return true;
        }

        return false;
      },
      isFirstRouteInParent: () => isFirstRouteInParent,
      dispatch: navigation.dispatch,
      getScreenProps: navigation.getScreenProps,
      dangerouslyGetParent: getCurrentParentNavigation,
      addListener: childSubscriber.addListener,
      emit: childSubscriber.emit
    });
    return children[childKey];
  }
}

export default getChildNavigation;
//# sourceMappingURL=getChildNavigation.js.map